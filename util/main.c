/*
* File: main.c
*
* C/C++ source code generated on  : Thu Jun 4 11:12:24 2015
* C/C++ source code generated by  : Alireza Ramezani, Champaign-Urbana-IL
* Target selection: stm32F4xx.tlc
* Embedded hardware selection: STMicroelectronics->STM32F4xx 32-bit Cortex-M4
* Code generation objectives:
*    1. Execution efficiency
*    2. ROM efficiency
*    3. RAM efficiency
*    4. Traceability
*    5. Safety precaution
*    6. Debugging
*    7. MISRA-C:2004 guidelines
*    8. Polyspace Model Link for Simulink
* Validation result: Passed (14), Warnings (2), Error (1)
*
*
*
* ******************************************************************************
* * attention
* *
* * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
* * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
* * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
* * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
* * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
* * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
* *
* ******************************************************************************
*/

#include <stdio.h>
#include "stddef.h"
#include "stm32f4xx.h"
#include "daq.h"
#include "vn100/vn100.h"
#include "rtwtypes.h"
#include "lida_screw.h"
#include "debug.h"

/* DAQ and controller loop at 1.0 KHz */
#define SAMPLE_TIME 0.01

/* Uncomment for debug msg over USART port */
#define DEBUG_MAIN

/* MACROS */
#define PI 3.141592654
#define DEG2RAD(x) x*PI/180
#define RAD2DEG(x) x*180/PI

/* this variable is used to create a time reference incremented by 1 mili-second */
#define SYSTEMTICK_PERIOD_MS 1

/* this variables are used to allocate a timer for the main application */
#define MAIN_TIM TIM7
#define MAIN_RCC_APBPeriph RCC_APB1Periph_TIM7

/* RCC_Configuration defined in RCC_Configuration.c file */
/* Clock configuration function provided as example */
extern void RCC_Configuration(void);

/* Real-time model */
extern RT_MODEL_daq *const daq_M;

/* Set which subrates need to run this base step (base rate always runs).*/
/* Defined in daq.c file */
extern void daq_SetEventsForThisBaseStep(boolean_T*);

/* Flags for taskOverrun */
static boolean_T OverrunFlags[1];

/* Number of auto reload timer rotation computed */
static uint32_t autoReloadTimerLoopVal_S = 1;

/* Remaining number of auto reload timer rotation to do */
static uint32_t remainAutoReloadTimerLoopVal_S = 1;


/* Private functions */
void main_delay_us(unsigned long us);
void main_delay_ms(unsigned long ms);
void main_initialize_us_timer(void);
void main_init_all();

/****************************************************
SysTick_Handler function
This handler is called every tick and schedules tasks
*****************************************************/
void SysTick_Handler(void)
{
	/* Manage nb of loop before interrupt has to be processed */
	remainAutoReloadTimerLoopVal_S--;
	if (remainAutoReloadTimerLoopVal_S) {
		return;
	}

	remainAutoReloadTimerLoopVal_S = autoReloadTimerLoopVal_S;

	/* Check base rate for overrun */
	if (OverrunFlags[0]) {
		rtmSetErrorStatus(daq_M, "Overrun");
		return;
	}

	OverrunFlags[0] = true;

	/* Functions here */
	sprintf(Buff, "%.1f %d %d\r\n", daq_Y.time, screw_position.direction, screw_position.percentage);
	debug_printf(Buff, 100);

	/* Step the model for base rate */
	daq_step();

	/* Indicate task for base rate complete */
	OverrunFlags[0] = false;
}

/****************************************************
main function
Example of main :
- Clock configuration
- call Initialize
- Wait for systick (infinite loop)
*****************************************************/
int main (void)
{
	main_init_all();

	/* First Demo */
	//screw_position_t screw_position;
	expected_position = 50;

	//PID_param_t PID_param;
	PID_param.Kp = 0.005;
	//PID_param.Kp = 0.01;
	PID_param.Ki = 0;
	//PID_param.Kd = 0.001;
	PID_param.Kd = 0;

	uint16_t compensate = 20;
	uint16_t dead_band = 2;
	uint16_t counter;

	//PID_data_t PID_data;

	daq_U.pwm5_3 = 0; // Tim4-Ch1
	//PWM_IC_init();
	MX_I2C_Init();
	screw_init(&screw_position);
	
	/* Infinite loop */
	/* Real time from systickHandler */
	daq_U.pwm5_3 = 0; // Tim4-Ch1

	while (1) 
	{
		/*
		float roll, pitch, yaw;
		
		roll = daq_Y.imuData[2];
		pitch = daq_Y.imuData[1];
		yaw = daq_Y.imuData[0];
		daq_U.pwm5_1 = 10; // Tim5-Ch1
		daq_U.pwm5_2 = 20; // Tim5-Ch2
		//daq_U.pwm5_3 = 30; // Tim4-Ch1
		daq_U.di1 = true;
		daq_U.di2 = true;
		daq_U.di3 = true;
		daq_U.di4 = true;
		daq_U.di5 = true;
		daq_U.di6 = true;
		daq_U.di7 = true;
		daq_U.di8 = true;
		daq_U.di9 = true;
		daq_U.di10 = true;
		daq_U.di12 = true;
		daq_U.di13 = true;
		daq_U.di14 = true;
		daq_U.di15 = true;
		daq_Y.do1;
		daq_Y.do2;
		daq_Y.do3;
		daq_Y.do4;
		daq_Y.do5;
		daq_Y.Estop;
		*/
		/*
		if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0))
		{
			GPIO_ResetBits(GPIOD, GPIO_Pin_15);
			while(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0));
			GPIO_SetBits(GPIOD, GPIO_Pin_15);
		}*/
		
		read_temp = MX_I2C_READ();
		if(read_temp != 65535)
		{
			if((int)read_temp < (int)screw_position.degree-180)
				screw_position.round ++;	
			if(read_temp > 180+screw_position.degree)
				screw_position.round --;
			screw_position.degree = read_temp;
		}
		screw_position.current_position = (uint32_t)screw_position.round*360 + screw_position.degree - screw_position.init_degree;
		screw_position.percentage = screw_position.current_position*100 / screw_position.range;

		if(screw_position.current_position > 80*screw_position.range/100)
			expected_position = 10;
		if(screw_position.current_position < 20*screw_position.range/100)
			expected_position = 90;
		
		motor_control = PID_generic (PID_param, &PID_data, \
						(int32_t)screw_position.current_position,\
						(int32_t)(expected_position*screw_position.range/100));
						
		if(motor_control >= -dead_band && motor_control <= dead_band)
		{
			GPIO_ResetBits(GPIOD, GPIO_Pin_15);
			daq_U.pwm5_3 = 0;
		}
		else if(motor_control > 0)
		{
			screw_position.direction = 1;
			GPIO_SetBits(GPIOD, GPIO_Pin_15);
			daq_U.pwm5_3 = motor_control + compensate;
		}
		else if(motor_control < 0)
		{
			screw_position.direction = 0;
			GPIO_ResetBits(GPIOD, GPIO_Pin_15);
			daq_U.pwm5_3 = -motor_control + compensate;
		}
		

		if(GPIO_ReadInputDataBit(GPIOD,GPIO_Pin_13))
		{
			screw_position.direction = 0;
			GPIO_ResetBits(GPIOD, GPIO_Pin_15);
			screw_position.round = screw_position.range/360;
			
		}

		if(GPIO_ReadInputDataBit(GPIOD,GPIO_Pin_14))
		{
			screw_position.direction = 1;
			GPIO_SetBits(GPIOD, GPIO_Pin_15);
			screw_position.round = 0;
		}
		
		//daq_U.pwm5_3 = compensate + 5; // Tim4-Ch1
		//GPIO_ResetBits(GPIOD, GPIO_Pin_13);
		//GPIO_ResetBits(GPIOD, GPIO_Pin_14);
		//read_temp = MX_I2C_READ();
		
	}	
}

/*******************************************************************************
* Function Name  : main_delay_us
* Input          : 
* Output         : None
* Return         : 
* Description    : 
*******************************************************************************/

void main_delay_us(unsigned long us)
{
	uint16_t t0 = MAIN_TIM->CNT;
	for (;;) {
		int t = MAIN_TIM->CNT;
		if (t < t0){
			t += 0x10000;
		}

		if (us < t - t0)
			return;

		us -= t - t0;
		t0 = t;
	}
}


/*******************************************************************************
* Function Name  : main_delay_ms
* Input          : 
* Output         : None
* Return         : 
* Description    : 
*******************************************************************************/

void main_delay_ms(unsigned long ms)
{
	main_delay_us(ms * 1000);
}


/*******************************************************************************
* Function Name  : main_initialize_us_timer
* Input          : 
* Output         : None
* Return         : 
* Description    : 
*******************************************************************************/

void main_initialize_us_timer()
{
	RCC_ClocksTypeDef RCC_Clocks;
	RCC_GetClocksFreq(&RCC_Clocks);

	RCC->APB1ENR |= MAIN_RCC_APBPeriph;
	MAIN_TIM->PSC = (RCC_Clocks.PCLK1_Frequency / 1000000) - 1;
	MAIN_TIM->ARR = 0xFFFF;
	MAIN_TIM->CR1 = TIM_CR1_CEN;
}

/*******************************************************************************
* Function Name  : main_init_all
* Input          : 
* Output         : None
* Return         : 
* Description    : 
*******************************************************************************/

void main_init_all()
{
	/* Data initialization */
	int_T i;
	for (i=0;i<1;i++) {
		OverrunFlags[i] = 0;
	}

	/* Clock has to be configured first*/
	RCC_Configuration();

	/* Initilaize the main application timer */
	main_initialize_us_timer();

	/* Model initialization call */
	daq_initialize();
	
	/* Initilaize the vn100 application */
	vn100_initialize_defaults();

	/* Systick configuration and enable SysTickHandler interrupt */
	float dt = SAMPLE_TIME;
	if (SysTick_Config((uint32_t)(SystemCoreClock * dt))) {
		autoReloadTimerLoopVal_S = 1;
		do {
			autoReloadTimerLoopVal_S++;
		} while ((uint32_t)(SystemCoreClock * dt)/autoReloadTimerLoopVal_S >
			SysTick_LOAD_RELOAD_Msk);

		SysTick_Config((uint32_t)(SystemCoreClock * dt)/autoReloadTimerLoopVal_S);
	}

	remainAutoReloadTimerLoopVal_S = autoReloadTimerLoopVal_S;//Set nb of loop to do
}
/* File trailer for Real-Time Workshop generated code.
*
* [EOF] main.c
*/
